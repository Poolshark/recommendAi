from flask import Flask, session, jsonify
from flask_session import Session
from textblob import TextBlob

class InputModule:
    def __init__(self):
        # Define sentiment-specific questions and responses
        self.sentiment_responses = {
            "happy": {
                "ask_occasion": "Are you celebrating something special today?",
                "ask_atmosphere": "Would you prefer a lively, upbeat atmosphere to match your mood?",
                "suggest_special": "I know some fantastic places with amazing ambiance that you might love!"
            },
            "neutral": {
                "ask_occasion": "Is this a casual dining experience or something specific you're looking for?",
                "ask_atmosphere": "What kind of atmosphere would you prefer - something relaxed or more energetic?",
                "suggest_special": "I can recommend some interesting places that might pique your interest."
            },
            "sad": {
                "ask_occasion": "Would you prefer a quiet, cozy place where you can relax?",
                "ask_atmosphere": "How about a restaurant with a warm, comfortable atmosphere?",
                "suggest_special": "I know some wonderful comfort food places that might help cheer you up."
            },
            "urgent": {
                "ask_occasion": "Quick check - any special requirements I should know about?",
                "ask_atmosphere": "For quick service, would you prefer casual dining or fast-casual?",
                "suggest_special": "I can recommend places known for quick service and minimal wait times.",
                "ask_time_day": "When do you need the table? I'll prioritize restaurants with immediate availability."
            }
        }

        # Define the conversation flow as a list of steps
        self.conversation_flow = [
            {
                "state": "greet",
                "question": "Hello! I'm Recommendy your restaurant recommendation assistant. How can I help you today? (For example: 'I'm looking for a restaurant for dinner' or 'I need a quick lunch spot')"
            },
            {
                "state": "ask_occasion",
                "question": lambda sentiment: self.sentiment_responses[sentiment]["ask_occasion"]
            },
            {
                "state": "ask_atmosphere",
                "question": lambda sentiment: self.sentiment_responses[sentiment]["ask_atmosphere"]
            },
            {
                "state": "ask_booking_history",
                "question": "Have you dined with any of our recommended restaurants before?"
            },
            {
                "state": "ask_dietary",
                "question": "Do you have any dietary restrictions or preferences I should know about?"
            },
            {
                "state": "ask_cuisine",
                "question": "What type of cuisine interests you today?"
            },
            {
                "state": "ask_time_day",
                "question": "When would you like to dine? Please provide day and time."
            },
            {
                "state": "ask_guests",
                "question": "How many people will be joining you?"
            },
            {
                "state": "ask_location",
                "question": "Which area would you prefer to dine in?"
            },
            {
                "state": "ask_budget",
                "question": "What's your comfortable budget range for this meal?"
            },
            {
                "state": "suggest_special",
                "question": lambda sentiment: self.sentiment_responses[sentiment]["suggest_special"]
            },
            {
                "state": "ask_ratings",
                "question": "Would you like to see ratings and reviews for the restaurants I have in mind?"
            },
            {
                "state": "confirm_booking",
                "question": "Just to confirm, you want to book a table for {guests} at a {cuisine} restaurant in {location} for {time}. Is that correct?"
            }
        ]

    def analyze_urgency(self, user_text: str) -> bool:
        """
        Analyze if the user's message indicates urgency
        """
        # Keywords indicating urgency
        urgency_keywords = [
            'quick', 'hurry', 'fast', 'asap', 'urgent', 'soon',
            'running late', 'immediately', 'right now', 'emergency',
            'quickly', 'rush', 'short time', 'busy', 'no time'
        ]
        
        # Time-related patterns indicating urgency
        time_patterns = [
            'next hour', 'within hour', '30 minutes', '15 minutes',
            'half hour', 'quarter hour'
        ]

        text = user_text.lower()
        
        # Check for urgency keywords
        has_urgency_keywords = any(keyword in text for keyword in urgency_keywords)
        
        # Check for time patterns
        has_time_urgency = any(pattern in text for pattern in time_patterns)
        
        # Check for exclamation marks (might indicate urgency)
        has_exclamations = '!' in text
        
        # Check for repeated punctuation (!!!???)
        has_repeated_punctuation = any(p * 2 in text for p in '!?.')
        
        # Return True if multiple urgency indicators are present
        urgency_score = sum([
            has_urgency_keywords,
            has_time_urgency,
            has_exclamations and has_repeated_punctuation
        ])
        
        return urgency_score >= 1
    
    def analyze_sentiment(self, user_text: str):
        blob = TextBlob(user_text)
        sentiment = blob.sentiment.polarity
        subjectivity = blob.sentiment.subjectivity
        
        # Enhanced sentiment analysis with subjectivity consideration
        if sentiment > 0.3:
            return "happy"
        elif sentiment < -0.2:
            return "sad"
        else:
            return "neutral"

    # Helper function: get current conversation index
    def get_current_step(self):
        return session.get('current_step', 0)

    # Helper function: advance conversation state
    def advance_step(self):
        current = self.get_current_step()
        if current < len(self.conversation_flow) - 1:
            session['current_step'] = current + 1
        else:
            session['current_step'] = current  # Stay at the last step if completed

    # Endpoint to initialize or reset the conversation
    def start_conversation(self):
        """Initialize or reset the conversation"""

        # Initialize or reset the conversation
        session['current_step'] = 0
        session['responses'] = {}
        session['sentiment'] = 'neutral'
        
        # Return initial greeting
        return jsonify({
            "question": self.conversation_flow[0]["question"],
            "state": self.conversation_flow[0]["state"]
        })
    

    def make_question_urgent(self, question: str) -> str:
        """Make questions more concise for urgent cases"""
        # Remove pleasantries and make questions more direct
        question = question.replace("Would you like", "Do you want")
        question = question.replace("Please provide", "Enter")
        question = question.replace("I would love to know", "Tell me")
        question = question.replace("Could you tell me", "What is")
        
        # Add urgency indicators when appropriate
        if "when" in question.lower():
            question = "ASAP: " + question
        
        return question

    def get_follow_up_question(self, sentiment, responses):
        """Generate follow-up questions based on sentiment and previous responses"""
        if sentiment == "urgent":
            if "time_day" not in responses:
                return "How soon do you need this?"
            return "Anything else crucial I should know?"
        elif sentiment == "sad":
            return "Would you like me to focus on restaurants known for their comfort food or peaceful atmosphere?"
        elif sentiment == "happy" and "occasion" in responses:
            return "Should I look for restaurants that are great for celebrations?"
        return None

    def get_sentiment_response(self, sentiment, user_text):
        """Generate appropriate responses based on sentiment"""
        if sentiment == "urgent":
            return "I understand you're in a hurry. I'll help you find something quickly."
        elif sentiment == "happy":
            return f"That's wonderful! {user_text}"
        elif sentiment == "sad":
            return f"I understand. Let me help you find something that might cheer you up. You said: {user_text}"
        else:
            return f"I see. You said: {user_text}"


    # Endpoint to process conversation input and return the next question
    def process_input(self, user_text: str):

        # Retrieve current conversation step index
        current_step = self.get_current_step()
        current_state = self.conversation_flow[current_step]["state"]

        # Store the user response in session
        responses = session.get('responses', {})
        responses[current_state] = user_text
        session['responses'] = responses

        # Only analyze sentiment after the greeting
        if current_state != "greet":
            sentiment = session.get('sentiment', 'neutral')
            is_urgent = session.get('is_urgent', False)
        else:
            # First user input - analyze sentiment and urgency
            is_urgent = self.analyze_urgency(user_text)
            sentiment = "urgent" if is_urgent else self.analyze_sentiment(user_text)
            
            # Store in session
            session['sentiment'] = sentiment
            session['is_urgent'] = is_urgent

            # If urgent, modify the conversation flow to skip non-essential questions
            if is_urgent:
                essential_states = {
                    'ask_time_day',
                    'ask_guests',
                    'ask_location',
                    'ask_dietary',
                    'confirm_booking'
                }
                
                # Find next essential question
                next_step = current_step + 1
                while (next_step < len(self.conversation_flow) - 1 and 
                       self.conversation_flow[next_step]["state"] not in essential_states):
                    next_step += 1
                
                session['current_step'] = next_step - 1  # -1 because advance_step will increment it

        # Get next question based on current state
        next_step = current_step + 1
        if next_step < len(self.conversation_flow):
            question = self.conversation_flow[next_step]["question"]
            
            # Apply sentiment-based question only after greeting
            if callable(question):
                next_question = question(sentiment)
            else:
                next_question = question

            # Modify question for urgent cases
            if is_urgent:
                next_question = self.make_question_urgent(next_question)

            # Add follow-up questions based on sentiment and previous responses
            # Only add follow-ups after greeting
            if current_state != "greet":
                follow_up = self.get_follow_up_question(sentiment, responses)
                if follow_up:
                    next_question = f"{next_question}\n{follow_up}"

            # Advance to the next step
            self.advance_step()

            return jsonify({
                "response": self.get_sentiment_response(sentiment, user_text) if current_state != "greet" else "Thank you for sharing! Let me help you find the perfect restaurant.",
                "next_question": next_question,
                "next_state": self.conversation_flow[next_step]["state"],
                "sentiment": sentiment,
                "current_conversation": responses
            }), 200
